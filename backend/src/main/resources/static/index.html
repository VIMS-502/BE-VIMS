<!DOCTYPE html>
<html>
<head>
    <title>Kurento WebRTC 화상회의 (로컬 테스트용)</title>
    <meta charset="UTF-8" />
    <style>
        body { font-family: Arial; margin: 20px; }
        .video-container { display: grid; grid-template-columns: repeat(auto-fit,minmax(320px,1fr)); gap: 20px; margin: 20px 0; }
        video { width: 100%; max-width: 320px; border:2px solid #ccc; border-radius:8px; }
        .controls { margin:20px 0; }
        button { padding:8px 16px; margin:4px; }
        .status, .connection-info { padding:10px; background:#f0f0f0; border-radius:4px; margin:8px 0; }
    </style>
</head>
<body>
<h1>Kurento WebRTC 화상회의 (로컬 테스트)</h1>

<div class="status">
    <p id="status">상태: 대기 중</p>
    <p id="connectionState">WebSocket: 연결 안됨</p>
    <p id="rtcState">WebRTC: 연결 안됨</p>
    <div id="connectionInfo" class="connection-info" style="display:none">
        <strong>연결 정보</strong>
        <div id="participantCount">참가자: 0명</div>
        <div id="videoStreams">활성 비디오: 0개</div>
    </div>
</div>

<div class="controls">
    <input id="roomInput" placeholder="방 이름" value="testRoom" />
    <input id="nameInput" placeholder="사용자 이름" value="User" />
    <button id="joinBtn" onclick="joinRoom()">방 참가</button>
    <button id="startVideoBtn" onclick="startVideo()" disabled>비디오 시작</button>
    <button id="leaveBtn" onclick="leaveRoom()" disabled>방 나가기</button>
    <button onclick="debugConnections()">상태 디버그</button>
    <button onclick="testReceiveVideoAnswer()">강제 receiveVideoAnswer</button>
</div>

<div class="video-container" id="videoContainer"></div>

<div>
    <h3>로그</h3>
    <div id="logs" style="height:200px;overflow-y:auto;background:#fafafa;border:1px solid #ddd;padding:8px;"></div>
</div>

<script>
    let socket, localStream, publishPc;
    // 참가자 관리: sessionId를 키, 값은 { pc, hasVideo, isLocal, name }
    let participants = {}, currentRoom;
    let currentSessionId = null, currentName = null;

    const statusEl = document.getElementById('status'),
        wsStateEl = document.getElementById('connectionState'),
        rtcStateEl = document.getElementById('rtcState'),
        infoEl = document.getElementById('connectionInfo'),
        partCountEl = document.getElementById('participantCount'),
        vidCountEl = document.getElementById('videoStreams'),
        logsEl = document.getElementById('logs'),
        videoContainer = document.getElementById('videoContainer'),
        joinBtn = document.getElementById('joinBtn'),
        startBtn = document.getElementById('startVideoBtn'),
        leaveBtn = document.getElementById('leaveBtn');

    function log(msg){
        const t = new Date().toLocaleTimeString();
        logsEl.innerHTML += `[${t}] ${msg}<br>`;
        logsEl.scrollTop = logsEl.scrollHeight;
        console.log(msg);
    }

    function updateStatus(s) { statusEl.textContent = '상태: ' + s; }
    function updateWS(s) { wsStateEl.textContent = 'WebSocket: ' + s; }
    function updateRTC(s) { rtcStateEl.textContent = 'WebRTC: ' + s; }
    function updateInfo(){
        const count = Object.keys(participants).length;
        const videos = Object.values(participants).filter(p => p.hasVideo).length;
        partCountEl.textContent = '참가자: ' + count + '명';
        vidCountEl.textContent = '활성 비디오: ' + videos + '개';
        infoEl.style.display = count > 0 ? 'block' : 'none';
    }

    function debugConnections(){
        log('=== 디버그 시작 ===');
        log('방: ' + currentRoom + ', 세션: ' + currentSessionId + ', 이름: ' + currentName);
        for(const sessionId in participants){
            const p = participants[sessionId];
            log(`세션ID:${sessionId} / 이름:${p.name} / hasVideo:${p.hasVideo} / pc 상태:${p.pc ? p.pc.connectionState : '없음'}`);
        }
        if(publishPc) log('Publish PC 상태: ' + publishPc.connectionState);
        log('=== 디버그 끝 ===');
    }

    // WebSocket 연결 함수
    function connectWS(token) {
        let url = 'ws://localhost:8080/signaling';
        if(token) url += `?token=${token}`;
        socket = new WebSocket(url);

        socket.onopen = () => {
            log(token ? 'WS 연결됨 (토큰 인증)' : 'WS 연결됨');
            updateWS('연결됨');
            sendMessage({ type: 'joinRoom', room: currentRoom, name: currentName });
        };

        socket.onmessage = evt => {
            log('RAW 수신: ' + evt.data);
            let msg;
            try {
                msg = JSON.parse(evt.data);
            } catch(e) {
                return log('파싱 오류');
            }
            log('수신: ' + msg.type);
            if(msg.type === 'receiveVideoAnswer')
                log('▶ receiveVideoAnswer ' + (msg.sessionId || msg.sender));
            handleMessage(msg);
        };

        socket.onerror = () => { log('WS 오류'); updateWS('오류'); };
        socket.onclose = () => { log('WS 종료'); updateWS('끊김'); };
    }

    function sendMessage(m){
        if(socket && socket.readyState === 1){
            socket.send(JSON.stringify(m));
            log('송신: ' + m.type);
        }
    }

    // 메시지 핸들러
    function handleMessage(m){
        switch(m.type) {
            case 'joinedRoom': onJoined(m); break;
            case 'existingParticipant':
                addParticipant(m.sessionId, m.name, false);
                if(localStream){
                    log(`기존 참가자 ${m.name}의 비디오 수신 시작`);
                    setTimeout(() => receiveVideo(m.sessionId, m.name), 1000);
                }
                break;
            case 'newParticipantArrived':
                addParticipant(m.sessionId, m.name, false);
                break;
            case 'participantLeft':
                removeParticipant(m.sessionId);
                break;
            case 'publishVideoAnswer':
                onPublishAnswer(m);
                break;
            case 'receiveVideoAnswer':
                onReceiveAnswer(m);
                break;
            case 'iceCandidate':
                onRemoteIce(m);
                break;
            case 'videoAvailable':
                if(localStream){
                    log(`${m.name}의 비디오 사용 가능 - 수신 시작`);
                    setTimeout(() => receiveVideo(m.sessionId, m.name), 500);
                }
                break;
            case 'error':
                log(`서버 오류: ${m.message}`);
                break;
        }
    }

    function joinRoom(){
        currentRoom = document.getElementById('roomInput').value.trim();
        currentName = document.getElementById('nameInput').value.trim() || 'Unknown';
        if(!currentRoom) { alert('방 이름을 입력해주세요'); return; }
        if(!currentName) { alert('사용자 이름을 입력해주세요'); return; }
        currentSessionId = null;
        connectWS();
    }

    function onJoined(m){
        log('방참가 ' + m.room);
        if(m.sessionId){
            currentSessionId = m.sessionId;
            log('서버에서 받은 세션ID로 업데이트: ' + currentSessionId);
        }
        if(m.name){
            currentName = m.name;
            log('서버에서 받은 이름으로 업데이트: ' + currentName);
        }
        updateStatus('방참가');
        joinBtn.disabled = true;
        startBtn.disabled = false;
        leaveBtn.disabled = false;
        addParticipant(currentSessionId, currentName, true);
    }

    function addParticipant(sessionId, name, isLocal){
        if(participants[sessionId]) return;
        participants[sessionId] = { pc: null, hasVideo: false, isLocal: isLocal, name: name };
        updateInfo();
    }

    function removeParticipant(sessionId){
        log('퇴장 ' + (participants[sessionId]?.name || sessionId));
        const wrapper = document.getElementById('wrapper-'+sessionId);
        if(wrapper) wrapper.remove();
        if(participants[sessionId] && participants[sessionId].pc)
            participants[sessionId].pc.close();
        delete participants[sessionId];
        updateInfo();
    }

    async function startVideo(){
        try {
            updateStatus('카메라');
            localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            createVideo(currentSessionId, currentName, localStream, true);
            participants[currentSessionId].hasVideo = true;
            updateInfo();
            await publish();
            startBtn.disabled = true;
            updateStatus('스트리밍');
        } catch(e) {
            log('getUserMedia 실패: ' + e.message);
        }
    }

    async function publish(){
        publishPc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
        publishPc.onicecandidate = e => e.candidate && sendMessage({
            type: 'onIceCandidate',
            sessionId: currentSessionId,
            name: currentName,
            candidate: e.candidate
        });
        publishPc.onconnectionstatechange = () => updateRTC(publishPc.connectionState);
        localStream.getTracks().forEach(t => publishPc.addTrack(t, localStream));
        const offer = await publishPc.createOffer();
        await publishPc.setLocalDescription(offer);
        sendMessage({ type:'publishVideo', sdpOffer: offer.sdp, sessionId: currentSessionId, name: currentName });
    }

    async function onPublishAnswer(m){
        await publishPc.setRemoteDescription({ type:'answer', sdp: m.sdpAnswer });
        for(const sessionId in participants){
            if(sessionId !== currentSessionId){
                receiveVideo(sessionId, participants[sessionId].name);
            }
        }
    }

    async function receiveVideo(sessionId, name){
        if(sessionId === currentSessionId) return;
        if(!participants[sessionId]){
            log(`${name} 참가자 정보가 없어 추가합니다`);
            addParticipant(sessionId, name, false);
        }
        if(participants[sessionId].pc){
            participants[sessionId].pc.close();
        }
        const pc = new RTCPeerConnection({ iceServers: [{ urls:'stun:stun.l.google.com:19302' }] });
        participants[sessionId].pc = pc;
        pc.onicecandidate = e => e.candidate && sendMessage({
            type: 'onIceCandidate',
            sessionId: sessionId,
            name: name,
            candidate: e.candidate
        });
        pc.ontrack = e => {
            log(`${name}의 비디오 트랙 수신됨 - 종류: ${e.track.kind}, 활성화: ${e.track.enabled}, 음소거: ${e.track.muted}`);
            if(e.track.kind === 'video'){
                e.track.enabled = true;
                log(`${name}의 비디오 트랙 강제 활성화`);
            }
            if(e.streams && e.streams[0]){
                const stream = e.streams[0];
                log(`${name}의 스트림 정보 - 트랙 수: ${stream.getTracks().length}`);
                stream.getTracks().forEach(track => {
                    log(`트랙: ${track.kind}, 활성화: ${track.enabled}, 음소거: ${track.muted}`);
                });
                createVideo(sessionId, name, stream, false);
                participants[sessionId].hasVideo = true;
                updateInfo();
                log(`${name}의 비디오 표시 완료`);
            } else {
                log(`${name}의 스트림이 없음`);
            }
        };
        pc.onconnectionstatechange = () => log(name + ' conn: ' + pc.connectionState);
        const offer = await pc.createOffer({ offerToReceiveAudio:true, offerToReceiveVideo:true });
        await pc.setLocalDescription(offer);
        sendMessage({ type:'receiveVideoFrom', sender: sessionId, name: name, sdpOffer: offer.sdp });
    }

    async function onReceiveAnswer(m){
        const pc = participants[m.sessionId]?.pc;
        if(pc){
            await pc.setRemoteDescription({ type:'answer', sdp: m.sdpAnswer });
            log(`${m.name || m.sessionId} 수신셋업 완료`);
        }
    }

    function onRemoteIce(m){
        if(m.sessionId === currentSessionId){
            if(publishPc && publishPc.remoteDescription){
                publishPc.addIceCandidate(new RTCIceCandidate(m.candidate)).catch(e => {
                    log(`자신의 ICE candidate 추가 실패: ${e.message}`);
                });
            } else {
                log(`자신의 ICE candidate 대기 중`);
            }
        } else {
            if(!participants[m.sessionId]){
                log(`${m.name || m.sessionId} 참가자 정보가 없어 ICE candidate 무시`);
                return;
            }
            const pc = participants[m.sessionId].pc;
            if(pc && pc.remoteDescription){
                pc.addIceCandidate(new RTCIceCandidate(m.candidate)).catch(e => {
                    log(`ICE candidate 추가 실패 (${m.name || m.sessionId}): ${e.message}`);
                });
            } else {
                log(`ICE candidate 대기 중 (${m.name || m.sessionId})`);
            }
        }
    }

    function createVideo(sessionId, name, stream, muted){
        let wrapper = document.getElementById('wrapper-' + sessionId);
        if(wrapper) wrapper.remove();
        wrapper = document.createElement('div');
        wrapper.id = 'wrapper-' + sessionId;
        wrapper.className = 'video-wrapper';

        const video = document.createElement('video');
        video.id = 'video-' + sessionId;
        video.autoplay = true;
        video.playsInline = true;
        video.muted = muted;
        video.srcObject = stream;

        video.onloadedmetadata = () => {
            log(`${name}의 비디오 메타데이터 로드됨`);
            video.play().catch(e => log(`${name} 비디오 재생 실패: ${e.message}`));
        };
        video.oncanplay = () => {
            log(`${name}의 비디오 재생 준비 완료`);
        };
        video.onerror = (e) => {
            log(`${name}의 비디오 오류: ${e.message || '알 수 없는 오류'}`);
        };

        const label = document.createElement('h4');
        label.textContent = name + (muted ? ' (나)' : '');
        wrapper.appendChild(label);
        wrapper.appendChild(video);
        videoContainer.appendChild(wrapper);

        log(`${name}의 비디오 엘리먼트 생성 완료`);
    }

    function testReceiveVideoAnswer(){
        const other = Object.keys(participants).find(id => id !== currentSessionId);
        if(!other){
            log('수신 대상 없음');
            return;
        }
        handleMessage({
            type: 'receiveVideoAnswer',
            sessionId: other,
            name: participants[other]?.name || other,
            sdpAnswer: 'v=0\r\no=- 0 0 IN IP4 0.0.0.0\r\ns=-\r\nt=0 0\r\n'
        });
    }

    function leaveRoom(){
        sendMessage({type:'leaveRoom', sessionId: currentSessionId, name: currentName});
        if(publishPc) publishPc.close();
        for(const id in participants) {
            if(participants[id].pc) participants[id].pc.close();
        }
        if(localStream){
            localStream.getTracks().forEach(t => t.stop());
        }
        socket.close();
        participants = {};
        videoContainer.innerHTML = '';
        joinBtn.disabled = false;
        startBtn.disabled = true;
        leaveBtn.disabled = true;
        updateStatus('나감');
        updateWS('끊김');
        updateRTC('끊김');
        updateInfo();
    }

    window.onbeforeunload = leaveRoom;
    window.onload = () => updateStatus('준비됨');
</script>

</body>
</html>
