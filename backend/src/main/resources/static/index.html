<!DOCTYPE html>
<html>
<head>
    <title>Kurento WebRTC 화상회의 (로컬 테스트용)</title>
    <meta charset="UTF-8" />
    <style>
        body { font-family: Arial; margin: 20px; }
        .video-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        video {
            width: 100%; max-width: 320px;
            border: 2px solid #ccc;
            border-radius: 8px;
        }
        .controls { margin: 20px 0; }
        button { padding: 8px 16px; margin: 4px; }
        .status, .connection-info {
            padding: 10px;
            background: #f0f0f0;
            border-radius: 4px;
            margin: 8px 0;
        }
    </style>
</head>
<body>
<h1>Kurento WebRTC 화상회의 (로컬 테스트)</h1>

<div class="status">
    <p id="status">상태: 대기 중</p>
    <p id="connectionState">WebSocket: 연결 안됨</p>
    <p id="rtcState">WebRTC: 연결 안됨</p>
    <div id="connectionInfo" class="connection-info" style="display:none">
        <strong>연결 정보</strong>
        <div id="participantCount">참가자: 0명</div>
        <div id="videoStreams">활성 비디오: 0개</div>
    </div>
</div>

<div class="controls">
    <input id="roomInput" placeholder="방 이름" value="testRoom" />
    <!-- 닉네임 입력창 없음 -->
    <button id="joinBtn" onclick="joinRoom()">방 참가</button>
    <button id="startVideoBtn" onclick="startVideo()" disabled>비디오 시작</button>
    <button id="leaveBtn" onclick="leaveRoom()" disabled>방 나가기</button>
    <button onclick="debugConnections()">상태 디버그</button>
    <button onclick="testReceiveVideoAnswer()">강제 receiveVideoAnswer</button>
</div>

<div class="video-container" id="videoContainer"></div>

<div>
    <h3>로그</h3>
    <div id="logs" style="height:200px; overflow-y:auto; background:#fafafa; border:1px solid #ddd; padding:8px;"></div>
</div>

<script>
    let socket, localStream, publishPc;
    // 참가자 관리: sessionId 키, 값은 {pc, hasVideo, isLocal, name}
    let participants = {};
    let currentRoom = null;
    let currentSessionId = null;
    let currentUser = null;
    let token = null;

    const statusEl = document.getElementById('status'),
        wsStateEl = document.getElementById('connectionState'),
        rtcStateEl = document.getElementById('rtcState'),
        infoEl = document.getElementById('connectionInfo'),
        partCountEl = document.getElementById('participantCount'),
        vidCountEl = document.getElementById('videoStreams'),
        logsEl = document.getElementById('logs'),
        videoContainer = document.getElementById('videoContainer'),
        joinBtn = document.getElementById('joinBtn'),
        startBtn = document.getElementById('startVideoBtn'),
        leaveBtn = document.getElementById('leaveBtn');

    // URL 파라미터에서 token, room 추출
    const urlParams = new URLSearchParams(window.location.search);
    token = urlParams.get('token');
    currentRoom = urlParams.get('room') || 'testRoom';

    // 로그 출력
    function log(msg){
        const t = new Date().toLocaleTimeString();
        logsEl.innerHTML += `[${t}] ${msg}<br>`;
        logsEl.scrollTop = logsEl.scrollHeight;
        console.log(msg);
    }

    function updateStatus(s) { statusEl.textContent = '상태: ' + s; }
    function updateWS(s) { wsStateEl.textContent = 'WebSocket: ' + s; }
    function updateRTC(s) { rtcStateEl.textContent = 'WebRTC: ' + s; }
    function updateInfo(){
        const count = Object.keys(participants).length;
        const videos = Object.values(participants).filter(p => p.hasVideo).length;
        partCountEl.textContent = `참가자: ${count}명`;
        vidCountEl.textContent = `활성 비디오: ${videos}개`;
        infoEl.style.display = count > 0 ? 'block' : 'none';
    }

    function addParticipant(sessionId, name, isLocal){
        if(participants[sessionId]) return;
        participants[sessionId] = { pc:null, hasVideo:false, isLocal, name };
        updateInfo();
    }

    function removeParticipant(sessionId){
        log(`퇴장 ${participants[sessionId]?.name || sessionId}`);
        const wrapper = document.getElementById('wrapper-' + sessionId);
        if(wrapper) wrapper.remove();
        if(participants[sessionId]?.pc) participants[sessionId].pc.close();
        delete participants[sessionId];
        updateInfo();
    }

    // 토큰 인증 연결
    function connectWSWithToken(token) {
        if(!token){
            alert('인증 토큰이 필요합니다.');
            updateWS('토큰 없음');
            return;
        }

        socket = new WebSocket(`ws://localhost:8080/signaling?token=${token}`);

        socket.onopen = () => {
            log('WS 연결됨 (토큰 인증)');
            updateWS('연결됨');
            // 최초 joinRoom 메시지는 sessionId와 name 모름 (서버에서 할당해서 보내줄 것)
            sendMessage({type: 'joinRoom', room: currentRoom});
        };

        socket.onmessage = evt => {
            let msg;
            try {
                msg = JSON.parse(evt.data);
            } catch(e) {
                log('파싱 오류: ' + e.message);
                return;
            }
            log('수신: ' + msg.type);

            if(msg.type === 'joinedRoom'){
                if(msg.sessionId && msg.name){
                    currentSessionId = msg.sessionId;
                    currentUser = msg.name;
                    log(`서버에서 할당된 세션ID: ${currentSessionId}, 이름: ${currentUser}`);
                    addParticipant(currentSessionId, currentUser, true);
                    joinBtn.disabled = true;
                    startBtn.disabled = false;
                    leaveBtn.disabled = false;
                    updateStatus('방참가 완료');
                } else {
                    log('joinedRoom 메시지에 sessionId 또는 name 누락');
                    log(msg.sessionId);
                    log(msg.name);
                }
            }

            handleMessage(msg);
        };

        socket.onerror = () => {
            log('WS 오류');
            updateWS('오류');
        };

        socket.onclose = () => {
            log('WS 종료');
            updateWS('끊김');
        };
    }

    // 임시 게스트 연결 시 (토큰 없을 때)
    function connectWS(){
        socket = new WebSocket('ws://localhost:8080/signaling');

        socket.onopen = () => {
            log('WS 연결됨');
            updateWS('연결됨');
            sendMessage({type: 'joinRoom', room: currentRoom});
        };

        socket.onmessage = evt => {
            let msg;
            try {
                msg = JSON.parse(evt.data);
            } catch(e) {
                log('파싱 오류: ' + e.message);
                return;
            }
            log('수신: ' + msg.type);

            // 서버에서 세션ID 할당 받기
            if(msg.type === 'joinedRoom'){
                if(msg.sessionId && msg.name){
                    currentSessionId = msg.sessionId;
                    currentUser = msg.name;
                    log(`서버에서 할당된 세션ID: ${currentSessionId}, 이름: ${currentUser}`);
                    addParticipant(currentSessionId, currentUser, true);
                    joinBtn.disabled = true;
                    startBtn.disabled = false;
                    leaveBtn.disabled = false;
                    updateStatus('방참가 완료');
                } else {
                    log('joinedRoom 메시지에 sessionId 또는 name 누락');
                }
            }

            handleMessage(msg);
        };

        socket.onerror = () => {
            log('WS 오류');
            updateWS('오류');
        };

        socket.onclose = () => {
            log('WS 종료');
            updateWS('끊김');
        };
    }

    function sendMessage(m) {
        if(socket && socket.readyState === 1) {
            socket.send(JSON.stringify(m));
            log('송신: ' + m.type);
        }
    }

    function handleMessage(m){
        switch(m.type){
            case 'existingParticipant':
                addParticipant(m.sessionId, m.name, false);
                if(localStream){
                    log(`기존 참가자 ${m.name} 비디오 수신 시작`);
                    setTimeout(() => receiveVideo(m.sessionId, m.name), 1000);
                }
                break;
            case 'newParticipantArrived':
                addParticipant(m.sessionId, m.name, false);
                break;
            case 'participantLeft':
                removeParticipant(m.sessionId);
                break;
            case 'publishVideoAnswer':
                onPublishAnswer(m);
                break;
            case 'receiveVideoAnswer':
                onReceiveAnswer(m);
                break;
            case 'iceCandidate':
                onRemoteIce(m);
                break;
            case 'videoAvailable':
                if(localStream){
                    log(`${m.name} 비디오 사용 가능 - 수신 시작`);
                    setTimeout(() => receiveVideo(m.sessionId, m.name), 500);
                }
                break;
            case 'error':
                log(`서버 오류: ${m.message}`);
                break;
        }
    }

    async function startVideo(){
        if(!currentSessionId || !currentUser){
            alert('아직 sessionId 또는 사용자 이름이 할당되지 않았습니다.');
            return;
        }
        try {
            updateStatus('카메라 접근 중');
            localStream = await navigator.mediaDevices.getUserMedia({ video:true,audio:true });
            createVideo(currentSessionId, currentUser, localStream, true);
            participants[currentSessionId].hasVideo = true;
            updateInfo();
            await publish();
            startBtn.disabled = true;
            updateStatus('스트리밍 중');
        } catch(e) {
            log('getUserMedia 실패: ' + e.message);
            alert('카메라 접근 실패: ' + e.message);
        }
    }

    async function publish(){
        if(!currentSessionId || !currentUser){
            log('publish 실패: sessionId 또는 사용자 이름이 할당되지 않음');
            return;
        }
        publishPc = new RTCPeerConnection({ iceServers:[{urls:'stun:stun.l.google.com:19302'}] });
        publishPc.onicecandidate = e => {
            if(e.candidate) {
                sendMessage({ type:'onIceCandidate', sessionId: currentSessionId, name: currentUser, candidate: e.candidate });
            }
        };
        publishPc.onconnectionstatechange = () => updateRTC(publishPc.connectionState);
        localStream.getTracks().forEach(track => publishPc.addTrack(track, localStream));
        const offer = await publishPc.createOffer();
        await publishPc.setLocalDescription(offer);
        sendMessage({ type:'publishVideo', sdpOffer: offer.sdp, sessionId: currentSessionId, name: currentUser });
    }

    async function onPublishAnswer(m){
        await publishPc.setRemoteDescription({ type:'answer', sdp: m.sdpAnswer });
        for(const sid in participants){
            if(sid !== currentSessionId){
                receiveVideo(sid, participants[sid].name);
            }
        }
    }

    async function receiveVideo(sessionId, name){
        if(sessionId === currentSessionId) return;
        if(!participants[sessionId]){
            log(`${name} 참가자 정보가 없어 추가`);
            addParticipant(sessionId, name, false);
        }
        if(participants[sessionId].pc) participants[sessionId].pc.close();

        const pc = new RTCPeerConnection({ iceServers:[{urls:'stun:stun.l.google.com:19302'}] });
        participants[sessionId].pc = pc;

        pc.onicecandidate = e => {
            if(e.candidate) {
                sendMessage({ type:'onIceCandidate', sessionId: sessionId, name: name, candidate: e.candidate });
            }
        };

        pc.ontrack = e => {
            log(`${name} 비디오 트랙 수신됨 (종류: ${e.track.kind})`);
            if(e.track.kind === 'video'){
                e.track.enabled = true;
                log(`${name} 비디오 트랙 활성화`);
            }
            if(e.streams && e.streams[0]){
                const stream = e.streams[0];
                createVideo(sessionId, name, stream, false);
                participants[sessionId].hasVideo = true;
                updateInfo();
                log(`${name} 비디오 표시 완료`);
            } else {
                log(`${name} 스트림 없음`);
            }
        };

        pc.onconnectionstatechange = () => log(`${name} 연결 상태: ${pc.connectionState}`);

        const offer = await pc.createOffer({ offerToReceiveAudio:true, offerToReceiveVideo:true });
        await pc.setLocalDescription(offer);
        sendMessage({ type:'receiveVideoFrom', sender: sessionId, name: name, sdpOffer: offer.sdp });
    }

    async function onReceiveAnswer(m){
        const pc = participants[m.sessionId]?.pc;
        if(pc){
            await pc.setRemoteDescription({ type:'answer', sdp: m.sdpAnswer });
            log(`${m.name || m.sessionId} 수신 셋업 완료`);
        }
    }

    function onRemoteIce(m){
        if(m.sessionId === currentSessionId){
            if(publishPc && publishPc.remoteDescription){
                publishPc.addIceCandidate(new RTCIceCandidate(m.candidate)).catch(e => {
                    log(`자신 ICE candidate 추가 실패: ${e.message}`);
                });
            } else {
                log('자신 ICE candidate 대기 중');
            }
        } else {
            if(!participants[m.sessionId]){
                log(`${m.name || m.sessionId} 참가자 정보 없어 ICE candidate 무시`);
                return;
            }
            const pc = participants[m.sessionId].pc;
            if(pc && pc.remoteDescription){
                pc.addIceCandidate(new RTCIceCandidate(m.candidate)).catch(e => {
                    log(`ICE candidate 추가 실패 (${m.name || m.sessionId}): ${e.message}`);
                });
            } else {
                log(`ICE candidate 대기 중 (${m.name || m.sessionId})`);
            }
        }
    }

    function createVideo(sessionId, name, stream, muted){
        let wrapper = document.getElementById('wrapper-'+sessionId);
        if(wrapper) wrapper.remove();
        wrapper = document.createElement('div');
        wrapper.id = 'wrapper-'+sessionId;
        wrapper.className = 'video-wrapper';

        const video = document.createElement('video');
        video.id = 'video-'+sessionId;
        video.autoplay = true;
        video.playsInline = true;
        video.muted = muted;
        video.srcObject = stream;

        video.onloadedmetadata = () => {
            log(`${name} 비디오 메타데이터 로드됨`);
            video.play().catch(e => log(`${name} 비디오 재생 실패: ${e.message}`));
        };
        video.oncanplay = () => {
            log(`${name} 비디오 재생 준비 완료`);
        };
        video.onerror = (e) => {
            log(`${name} 비디오 오류: ${e.message || '알 수 없는 오류'}`);
        };

        const label = document.createElement('h4');
        label.textContent = name+(muted ? ' (나)' : '');
        wrapper.appendChild(label);
        wrapper.appendChild(video);

        videoContainer.appendChild(wrapper);

        log(`${name} 비디오 엘리먼트 생성 완료`);
    }

    function testReceiveVideoAnswer(){
        const other = Object.keys(participants).find(id => id !== currentSessionId);
        if(!other){
            log('수신 대상 없음');
            return;
        }
        handleMessage({
            type: 'receiveVideoAnswer',
            sessionId: other,
            name: participants[other]?.name || other,
            sdpAnswer: 'v=0\r\no=- 0 0 IN IP4 0.0.0.0\r\ns=-\r\nt=0 0\r\n'
        });
    }

    function joinRoom(){
        currentRoom = document.getElementById('roomInput').value.trim();
        if(!currentRoom){
            alert('방 이름을 입력해주세요');
            return;
        }
        if(token){
            connectWSWithToken(token);
        } else {
            // 토큰 없는 경우 게스트 ID 생성 및 연결
            currentSessionId = 'guest-' + Math.floor(Math.random() * 10000);
            currentUser = currentSessionId;
            connectWS();
            joinBtn.disabled = true;
            startBtn.disabled = false;
            leaveBtn.disabled = false;
        }
    }

    function leaveRoom(){
        if(socket && socket.readyState === 1){
            sendMessage({ type:'leaveRoom', sessionId: currentSessionId, name: currentUser });
        }
        if(publishPc) publishPc.close();
        for(let sid in participants){
            if(participants[sid].pc) participants[sid].pc.close();
        }
        if(localStream){
            localStream.getTracks().forEach(track => track.stop());
        }
        if(socket){
            socket.close();
        }
        participants = {};
        videoContainer.innerHTML = '';
        joinBtn.disabled = false;
        startBtn.disabled = true;
        leaveBtn.disabled = true;
        updateStatus('나감');
        updateWS('끊김');
        updateRTC('끊김');
        updateInfo();
    }

    window.onbeforeunload = leaveRoom;
    window.onload = () => updateStatus('준비됨');

    // URL에 토큰과 룸이 있을 경우 페이지 로드 후 자동 입장 시도
    if(currentRoom && token){
        document.getElementById('roomInput').value = currentRoom;
        setTimeout(() => {
            joinRoom();
            setTimeout(async () => {
                if(socket && socket.readyState === 1){
                    await startVideo();
                }
            }, 2000);
        }, 500);
    }
</script>
</body>
</html>
